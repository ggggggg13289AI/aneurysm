# Z 軸（張數）標註中位數計算 - 修正說明

## ✅ 已修正！

您的理解完全正確！程式現在**只看 z 軸（張數）有沒有標註**。

## 問題分析

### ❌ 修正前的問題

**原始程式碼：**
```python
pitch_slices = np.where(pitch_array == mask_index)[0]
median_slice = int(np.median(pitch_slices))
```

**問題：**
如果 `pitch_array` 是 3D 陣列 `(z, y, x)`，`np.where()[0]` 會返回**所有**符合條件的 z 索引，包含重複。

**範例情境：**
```
動脈瘤 #1 的標註情況：
  第 10 張: 有 500 個像素標註 → 返回 [10, 10, 10, ..., 10] (500 個)
  第 11 張: 有 300 個像素標註 → 返回 [11, 11, 11, ..., 11] (300 個)
  第 12 張: 有 100 個像素標註 → 返回 [12, 12, 12, ..., 12] (100 個)
  第 13 張: 有 200 個像素標註 → 返回 [13, 13, 13, ..., 13] (200 個)
  第 14 張: 有 400 個像素標註 → 返回 [14, 14, 14, ..., 14] (400 個)

pitch_slices = [10, 10, ..., 11, 11, ..., 12, ..., 13, ..., 14, 14, ...]
總長度: 1500 個元素

中位數: 11 (偏向像素多的張數)
角度: 11 × 3 - 3 = 30°
```

**問題：中位數會偏向標註像素多的張數！**

### ✅ 修正後的解決方案

**新程式碼：**
```python
# 找出哪些 z 切片（張數）有標註
# 對 y, x 軸做 any 操作，只看 z 軸是否有標註
has_annotation = np.any(pitch_array == mask_index, axis=(1, 2))
slices_with_annotation = np.where(has_annotation)[0]
median_slice = int(np.median(slices_with_annotation))
```

**解決方法：**
使用 `np.any(axis=(1, 2))` 沿著 y, x 軸做 OR 運算，只保留 z 軸資訊。

**同樣的範例：**
```
動脈瘤 #1 的標註情況：
  第 10 張: 有標註 → 記錄 10
  第 11 張: 有標註 → 記錄 11
  第 12 張: 有標註 → 記錄 12
  第 13 張: 有標註 → 記錄 13
  第 14 張: 有標註 → 記錄 14

slices_with_annotation = [10, 11, 12, 13, 14]
總長度: 5 個元素（去重！）

中位數: 12 (真正的張數中位數)
角度: 12 × 3 - 3 = 33°
```

**正確：只看「哪些張數有標註」，不受每張像素數量影響！**

## 程式碼對比

### 修正前
```python
# ❌ 會包含重複的張數索引
pitch_slices = np.where(pitch_array == mask_index)[0]
# 結果: [10, 10, 10, ..., 11, 11, ..., 12, ...]
#       (像素多的張數會重複很多次)

median_slice = int(np.median(pitch_slices))
# 中位數受像素數量影響
```

### 修正後
```python
# ✅ 只看張數是否有標註（去重）
has_annotation = np.any(pitch_array == mask_index, axis=(1, 2))
slices_with_annotation = np.where(has_annotation)[0]
# 結果: [10, 11, 12, 13, 14]
#       (每張只出現一次)

median_slice = int(np.median(slices_with_annotation))
# 純粹的「張數」中位數
```

## np.any() 運作原理

```python
# 假設 3D 陣列形狀: (30, 256, 256) = (z, y, x)

# 對每一張（z 切片），檢查是否有任何像素等於 mask_index
has_annotation = np.any(pitch_array == mask_index, axis=(1, 2))
# axis=(1, 2) 表示沿著 y, x 軸做 OR 運算
# 結果: [False, True, False, True, ..., False]
#       長度 30（對應 30 張）

# 找出 True 的位置（有標註的張數）
slices_with_annotation = np.where(has_annotation)[0]
# 結果: [1, 3, 10, 11, 12, 13, 14, ...]
```

## 視覺化說明

```
3D 陣列: (z=5, y=4, x=4)

第 0 張:  [0 0 0 0]     第 1 張:  [0 0 0 0]     第 2 張:  [0 0 0 0]
         [0 0 0 0]              [0 1 1 0]              [0 0 0 0]
         [0 0 0 0]              [0 1 1 0]              [0 0 0 0]
         [0 0 0 0]              [0 0 0 0]              [0 0 0 0]
         無標註                  有標註 (4像素)          無標註

第 3 張:  [1 1 0 0]     第 4 張:  [0 0 0 0]
         [1 1 0 0]              [0 0 0 0]
         [0 0 0 0]              [0 0 0 0]
         [0 0 0 0]              [0 0 0 0]
         有標註 (4像素)          無標註

np.any(axis=(1,2)) → [False, True, False, True, False]
                          ↓     ↓            ↓
                         第1張  第3張
                         有標註 有標註

slices_with_annotation = [1, 3]
中位數 = (1 + 3) / 2 = 2
角度 = 2 × 3 - 3 = 3°
```

## 差異對比

| 項目 | 修正前 | 修正後 |
|-----|-------|-------|
| **取得的資料** | 所有像素的 z 索引（有重複） | 有標註的張數（去重） |
| **陣列長度** | 可能數千個元素 | 實際的張數 |
| **受影響因素** | 每張的像素數量 | 只看是否有標註 |
| **中位數含義** | 偏向像素多的張數 | 真正的張數中位數 |
| **正確性** | ❌ 錯誤 | ✅ 正確 |

## 實際範例

假設動脈瘤在以下張數有標註：

| 張數 | 修正前（像素數） | 修正後 |
|-----|----------------|--------|
| 10  | 500 個 10      | 1 個 10 |
| 11  | 300 個 11      | 1 個 11 |
| 12  | 100 個 12      | 1 個 12 |
| 13  | 200 個 13      | 1 個 13 |
| 14  | 400 個 14      | 1 個 14 |

**修正前：**
- 陣列：`[10, 10, ..., 11, ..., 12, ..., 13, ..., 14, 14, ...]`
- 中位數：11（偏向 10 和 14）
- 角度：30°

**修正後：**
- 陣列：`[10, 11, 12, 13, 14]`
- 中位數：12（真正的中間張數）
- 角度：33°

**差異：3°**

## 總結

✅ **現在程式正確地只看「z 軸（張數）有沒有標註」**

- 使用 `np.any(axis=(1, 2))` 檢查每張是否有標註
- 不受每張標註像素數量的影響
- 計算真正的「張數」中位數
- 同時修正了 Pitch 和 Yaw 兩個方向

## 修正的檔案

`code_ai/pipeline/dicomseg/aneurysm_radax.py`
- 第 287-302 行：Pitch 方向
- 第 304-319 行：Yaw 方向

兩處都已使用相同的修正邏輯！

