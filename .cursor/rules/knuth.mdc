---
alwaysApply: true
---
# Donald Knuth é¢¨æ ¼æ ¸å¿ƒç®—æ³•è¦ç¯„ (Linus å„ªå…ˆç›¸å®¹ç‰ˆ)

## ğŸš¨ é‡è¦åŸå‰‡ï¼šLinus é¢¨æ ¼å„ªå…ˆ

**æ­¤è¦ç¯„åƒ…é©ç”¨æ–¼æ ¸å¿ƒç®—æ³•å±¤ï¼Œä¸”å¿…é ˆå®Œå…¨ç›¸å®¹æ–¼ Linus é¢¨æ ¼ç¨‹å¼ç¢¼å¯©æŸ¥æ¨™æº–ã€‚**

æ‰€æœ‰ Knuth é¢¨æ ¼çš„å¯¦ç¾éƒ½å¿…é ˆï¼š
1. **å…ˆé€šé Linus é¢¨æ ¼æª¢æŸ¥** - ç¸®æ’ä¸è¶…é 3 å±¤ã€æ¶ˆé™¤ç‰¹æ®Šæƒ…æ³ã€ä½¿ç”¨è³‡æ–™çµæ§‹è§£æ±ºå•é¡Œ
2. **ä¿æŒ Good Taste** - ç°¡æ½”ã€å¯¦ç”¨ã€ç„¡åµŒå¥—
3. **æ•ˆèƒ½å„ªå…ˆ** - æ–‡æª”ä¸èƒ½å½±éŸ¿åŸ·è¡Œæ•ˆç‡

## é©ç”¨ç¯„åœ

### âœ… é©ç”¨æ¨¡çµ„ (æ ¸å¿ƒç®—æ³•å±¤)
```
code_ai/
â”œâ”€â”€ dicom2nii/convert/          # DICOM è½‰æ›ç®—æ³•
â”œâ”€â”€ pipeline/                   # å½±åƒè™•ç†ç®¡é“
â”œâ”€â”€ SynthSeg/                   # è…¦éƒ¨åˆ†å‰²ç®—æ³•
â”œâ”€â”€ utils/parcellation/         # è…¦å€åˆ†å‰²å·¥å…·
â”œâ”€â”€ utils/inference/            # æ¨ç†ç®—æ³•
â””â”€â”€ utils/resample/             # é‡æ¡æ¨£ç®—æ³•
```

### âŒ ä¸é©ç”¨æ¨¡çµ„ (åš´æ ¼éµå¾ª Linus é¢¨æ ¼)
```
backend/app/routers/            # FastAPI è·¯ç”± - ç°¡æ½”å„ªå…ˆ
backend/app/database.py         # è³‡æ–™åº«æ“ä½œ - æ•ˆèƒ½å„ªå…ˆ
backend/app/middleware.py       # ä¸­ä»‹è»Ÿé«” - å¯¦ç”¨å„ªå…ˆ
æ‰€æœ‰å…¶ä»–æ¥­å‹™é‚è¼¯æ¨¡çµ„
```

## æ ¸å¿ƒåŸå‰‡ (Linus ç›¸å®¹ç‰ˆ)

### 1. æ–‡å­¸åŒ–ç·¨ç¨‹ + Good Taste
```python
# âœ… æ­£ç¢ºï¼šLinus + Knuth é¢¨æ ¼
"""
Â§1. DICOM åˆ° NIfTI è½‰æ›çš„æ ¸å¿ƒç®—æ³•

å•é¡Œï¼šå°‡ DICOM å½±åƒåºåˆ—è½‰æ›ç‚º NIfTI æ ¼å¼ï¼Œä¿æŒç©ºé–“è³‡è¨Šçš„æº–ç¢ºæ€§ã€‚
ç­–ç•¥ï¼šä½¿ç”¨è³‡æ–™çµæ§‹é©…å‹•çš„è½‰æ›ç®¡é“ï¼Œé¿å…ç‰¹æ®Šæƒ…æ³è™•ç†ã€‚

æ™‚é–“è¤‡é›œåº¦ï¼šO(n) where n = å½±åƒåˆ‡ç‰‡æ•¸é‡
ç©ºé–“è¤‡é›œåº¦ï¼šO(1) é¡å¤–ç©ºé–“ï¼ˆæµå¼è™•ç†ï¼‰
"""

# è½‰æ›å™¨æ˜ å°„è¡¨ - æ¶ˆé™¤ if/else éˆ (Linus åŸå‰‡)
DICOM_CONVERTERS = {
    'T1': convert_t1_sequence,
    'T2': convert_t2_sequence,
    'DWI': convert_dwi_sequence,
    'FLAIR': convert_flair_sequence,
}

def convert_dicom_to_nifti(dicom_path: Path, output_path: Path) -> ConversionResult:
    """
    Â§1.1 ä¸»è½‰æ›å‡½æ•¸
    
    ä¸è®Šå¼ï¼šè¼¸å…¥ DICOM å¿…é ˆåŒ…å«å®Œæ•´çš„ç©ºé–“è³‡è¨Šæ¨™ç±¤
    å¾Œç½®æ¢ä»¶ï¼šè¼¸å‡º NIfTI ä¿æŒåŸå§‹çš„é«”ç´ é–“è·å’Œæ–¹å‘è³‡è¨Š
    """
    # Â§1.2 æ—©æœŸé©—è­‰ (Linus é¢¨æ ¼)
    if not dicom_path.exists():
        return ConversionResult.error("DICOM æª”æ¡ˆä¸å­˜åœ¨")
    
    if not _has_spatial_info(dicom_path):
        return ConversionResult.error("ç¼ºå°‘ç©ºé–“è³‡è¨Šæ¨™ç±¤")
    
    # Â§1.3 åºåˆ—é¡å‹æª¢æ¸¬
    sequence_type = _detect_sequence_type(dicom_path)
    converter = DICOM_CONVERTERS.get(sequence_type, convert_default_sequence)
    
    # Â§1.4 åŸ·è¡Œè½‰æ› (ç„¡åµŒå¥—ï¼Œæ‰å¹³çµæ§‹)
    return converter(dicom_path, output_path)

# âŒ éŒ¯èª¤ï¼šé•å Linus åŸå‰‡çš„æ·±åº¦åµŒå¥—
def bad_convert_dicom(dicom_path):
    if dicom_path.exists():
        if _has_spatial_info(dicom_path):
            sequence_type = _detect_sequence_type(dicom_path)
            if sequence_type == 'T1':
                if _is_reformatted(dicom_path):
                    # 5 å±¤ç¸®æ’ï¼é•å Linus åŸå‰‡
                    return convert_reformatted_t1(dicom_path)
```

### 2. æ•¸å­¸åš´è¬¹æ€§ (ç°¡æ½”ç‰ˆ)
```python
def resample_to_isotropic(image_data: np.ndarray, voxel_size: Tuple[float, float, float]) -> np.ndarray:
    """
    Â§2. é‡æ¡æ¨£åˆ°ç­‰å‘æ€§é«”ç´ 
    
    ç®—æ³•ï¼šä¸‰ç·šæ€§æ’å€¼é‡æ¡æ¨£
    è¼¸å…¥ï¼šåŸå§‹å½±åƒ + ç›®æ¨™é«”ç´ å¤§å°
    è¼¸å‡ºï¼šç­‰å‘æ€§é‡æ¡æ¨£å½±åƒ
    
    æ•¸å­¸åŸºç¤ï¼š
    æ–°åº§æ¨™ = åŸåº§æ¨™ Ã— (åŸé«”ç´ å¤§å° / ç›®æ¨™é«”ç´ å¤§å°)
    
    è¤‡é›œåº¦ï¼šO(xyz) where x,y,z ç‚ºå½±åƒç¶­åº¦
    """
    # è¨ˆç®—ç¸®æ”¾å› å­ - ç°¡æ½”çš„æ•¸å­¸è¡¨é”
    scale_factors = np.array(voxel_size) / np.array(image_data.shape)
    
    # ä½¿ç”¨ scipy çš„æœ€ä½³åŒ–å¯¦ç¾ - é¿å…é‡æ–°ç™¼æ˜è¼ªå­
    return zoom(image_data, scale_factors, order=1)
    
    # æ³¨è¨˜ï¼šorder=1 è¡¨ç¤ºç·šæ€§æ’å€¼ï¼Œåœ¨é†«å­¸å½±åƒä¸­å¹³è¡¡å“è³ªèˆ‡æ•ˆèƒ½
```

### 3. éŒ¯èª¤è™•ç† (Linus + Knuth)
```python
class ImageProcessingResult:
    """è™•ç†çµæœçš„è³‡æ–™çµæ§‹ - é¿å…ç•°å¸¸è™•ç†çš„è¤‡é›œæ€§"""
    success: bool
    data: Optional[np.ndarray]
    error_message: str
    processing_time: float
    
    @classmethod
    def ok(cls, data: np.ndarray, time: float) -> 'ImageProcessingResult':
        return cls(True, data, "", time)
    
    @classmethod
    def error(cls, message: str) -> 'ImageProcessingResult':
        return cls(False, None, message, 0.0)

def process_brain_segmentation(image: np.ndarray) -> ImageProcessingResult:
    """
    Â§3. è…¦éƒ¨åˆ†å‰²è™•ç†
    
    ç®—æ³•ï¼šSynthSeg æ·±åº¦å­¸ç¿’åˆ†å‰²
    å‰ç½®æ¢ä»¶ï¼šè¼¸å…¥ç‚º T1 åŠ æ¬Š MRI å½±åƒ
    å¾Œç½®æ¢ä»¶ï¼šè¼¸å‡º 104 å€‹è…¦å€çš„åˆ†å‰²æ¨™ç±¤
    """
    start_time = time.time()
    
    # æ—©æœŸé©—è­‰ - Linus é¢¨æ ¼
    if image.ndim != 3:
        return ImageProcessingResult.error("è¼¸å…¥å¿…é ˆç‚º 3D å½±åƒ")
    
    if image.dtype != np.float32:
        return ImageProcessingResult.error("è¼¸å…¥å¿…é ˆç‚º float32 é¡å‹")
    
    # åŸ·è¡Œåˆ†å‰² - ç°¡æ½”å¯¦ç¾
    try:
        segmentation = _run_synthseg_inference(image)
        processing_time = time.time() - start_time
        return ImageProcessingResult.ok(segmentation, processing_time)
    
    except Exception as e:
        return ImageProcessingResult.error(f"åˆ†å‰²å¤±æ•—: {str(e)}")
```

## æ–‡æª”è¦æ±‚ (ç°¡åŒ–ç‰ˆ)

### å¿…è¦æ–‡æª”å…ƒç´ 
```python
def algorithm_function():
    """
    Â§X. ç®—æ³•åç¨±
    
    å•é¡Œï¼šç°¡æ½”æè¿°è¦è§£æ±ºçš„å•é¡Œ
    ç­–ç•¥ï¼šä¸€å¥è©±èªªæ˜è§£æ±ºæ–¹æ¡ˆ
    è¤‡é›œåº¦ï¼šO(?) æ™‚é–“ï¼ŒO(?) ç©ºé–“
    
    å‰ç½®æ¢ä»¶ï¼šè¼¸å…¥è¦æ±‚
    å¾Œç½®æ¢ä»¶ï¼šè¼¸å‡ºä¿è­‰
    """
    pass
```

### âŒ é¿å…éåº¦æ–‡æª”åŒ–
```python
# âŒ éŒ¯èª¤ï¼šéåº¦è©³ç´°ï¼Œé•å Linus ç°¡æ½”åŸå‰‡
def bad_documented_function():
    """
    é€™å€‹å‡½æ•¸å¯¦ç¾äº†éå¸¸è¤‡é›œçš„ç®—æ³•ï¼Œé¦–å…ˆæˆ‘å€‘éœ€è¦ç†è§£æ­·å²èƒŒæ™¯...
    (500 è¡Œæ–‡æª”)
    ç„¶å¾Œæˆ‘å€‘åˆ†ææ¯ä¸€å€‹æ­¥é©Ÿçš„æ•¸å­¸åŸç†...
    (åˆ 300 è¡Œæ–‡æª”)
    """
    pass

# âœ… æ­£ç¢ºï¼šç°¡æ½”ä½†å®Œæ•´
def good_documented_function():
    """
    Â§1. å¿«é€Ÿå‚…ç«‹è‘‰è®Šæ›å¯¦ç¾
    
    ç®—æ³•ï¼šCooley-Tukey FFT
    è¤‡é›œåº¦ï¼šO(n log n)
    ç”¨é€”ï¼šé »åŸŸæ¿¾æ³¢é è™•ç†
    """
    pass
```

## æ¸¬è©¦è¦æ±‚

### æ ¸å¿ƒç®—æ³•æ¸¬è©¦
```python
class TestDicomConversion:
    """Â§4. DICOM è½‰æ›ç®—æ³•æ¸¬è©¦å¥—ä»¶"""
    
    def test_t1_conversion_correctness(self):
        """Â§4.1 T1 åºåˆ—è½‰æ›æ­£ç¢ºæ€§é©—è­‰"""
        # æ¸¬è©¦è³‡æ–™
        dicom_path = Path("test_data/t1_sequence.dcm")
        expected_shape = (256, 256, 180)
        
        # åŸ·è¡Œè½‰æ›
        result = convert_dicom_to_nifti(dicom_path, Path("output.nii"))
        
        # é©—è­‰çµæœ
        assert result.success
        assert result.data.shape == expected_shape
        assert result.processing_time < 5.0  # æ•ˆèƒ½è¦æ±‚
    
    def test_edge_cases(self):
        """Â§4.2 é‚Šç•Œæƒ…æ³æ¸¬è©¦"""
        # ç©ºæª”æ¡ˆ
        assert not convert_dicom_to_nifti(Path("empty.dcm"), Path("out.nii")).success
        
        # æå£æª”æ¡ˆ
        assert not convert_dicom_to_nifti(Path("corrupt.dcm"), Path("out.nii")).success
```

## æ•ˆèƒ½åŸºæº–

### å¿…è¦çš„æ•ˆèƒ½æ¸¬è©¦
```python
def benchmark_core_algorithms():
    """Â§5. æ ¸å¿ƒç®—æ³•æ•ˆèƒ½åŸºæº–æ¸¬è©¦"""
    
    # æ¸¬è©¦ä¸åŒå¤§å°çš„å½±åƒ
    sizes = [(128, 128, 64), (256, 256, 128), (512, 512, 256)]
    
    for size in sizes:
        test_image = np.random.rand(*size).astype(np.float32)
        
        # æ¸¬é‡è™•ç†æ™‚é–“
        start = time.perf_counter()
        result = process_brain_segmentation(test_image)
        end = time.perf_counter()
        
        # é©—è­‰æ•ˆèƒ½è¦æ±‚
        assert result.success
        assert (end - start) < size[0] * size[1] * size[2] / 1000000  # ç·šæ€§æ™‚é–“
```

## èˆ‡å…¶ä»–è¦å‰‡çš„æ•´åˆ

### 1. èˆ‡ FastAPI è·¯ç”±çš„æ¥å£
```python
# æ ¸å¿ƒç®—æ³•å±¤ (Knuth é¢¨æ ¼)
def convert_dicom_core(dicom_data: bytes) -> ConversionResult:
    """Â§6. æ ¸å¿ƒè½‰æ›é‚è¼¯ (è©³ç›¡æ–‡æª”)"""
    pass

# æ¥å£å±¤ (Linus é¢¨æ ¼)
@router.post("/convert")
async def convert_dicom_endpoint(file: UploadFile) -> ConversionResponse:
    """ç°¡æ½”çš„ API ç«¯é» - ç„¡è©³ç›¡æ–‡æª”"""
    if not file.filename.endswith('.dcm'):
        raise HTTPException(422, "åªæ”¯æ´ DICOM æª”æ¡ˆ")
    
    result = convert_dicom_core(await file.read())
    if not result.success:
        raise HTTPException(500, result.error_message)
    
    return ConversionResponse.from_result(result)
```

### 2. èˆ‡è³‡æ–™åº«æ“ä½œçš„æ•´åˆ
```python
# æ ¸å¿ƒç®—æ³• (Knuth é¢¨æ ¼)
async def process_medical_image(image_data: np.ndarray) -> ProcessingResult:
    """Â§7. é†«å­¸å½±åƒè™•ç†æ ¸å¿ƒç®—æ³•"""
    pass

# è³‡æ–™åº«å±¤ (æ•ˆèƒ½å„ªå…ˆï¼ŒLinus é¢¨æ ¼)
async def save_processing_result(db: AsyncSession, result: ProcessingResult) -> None:
    """ç°¡æ½”çš„è³‡æ–™åº«æ“ä½œ - æ•ˆèƒ½å„ªå…ˆ"""
    if not result.success:
        return
    
    record = ProcessingRecord(**result.to_dict())
    db.add(record)
    await db.commit()
```

## ç¨‹å¼ç¢¼å¯©æŸ¥æª¢æŸ¥æ¸…å–®

### Linus é¢¨æ ¼æª¢æŸ¥ (å„ªå…ˆ)
- [ ] ç¸®æ’æ˜¯å¦è¶…é 3 å±¤ï¼Ÿ
- [ ] æ˜¯å¦æœ‰ç‰¹æ®Šæƒ…æ³è™•ç†ï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨è³‡æ–™çµæ§‹è§£æ±ºå•é¡Œï¼Ÿ
- [ ] æ˜¯å¦ç¬¦åˆ Good Taste åŸå‰‡ï¼Ÿ

### Knuth é¢¨æ ¼æª¢æŸ¥ (æ¬¡è¦)
- [ ] æ˜¯å¦åŒ…å«ç®—æ³•æè¿°ï¼Ÿ
- [ ] æ˜¯å¦åˆ†æäº†è¤‡é›œåº¦ï¼Ÿ
- [ ] æ˜¯å¦æœ‰å‰ç½®/å¾Œç½®æ¢ä»¶ï¼Ÿ
- [ ] æ˜¯å¦æœ‰é©ç•¶çš„æ¸¬è©¦ï¼Ÿ

### æ•´åˆæª¢æŸ¥
- [ ] æ ¸å¿ƒç®—æ³•æ˜¯å¦èˆ‡æ¥å£å±¤è§£è€¦ï¼Ÿ
- [ ] æ˜¯å¦å½±éŸ¿æ•´é«”ç³»çµ±æ•ˆèƒ½ï¼Ÿ
- [ ] æ–‡æª”æ˜¯å¦ç°¡æ½”è€Œå®Œæ•´ï¼Ÿ

## ç¸½çµ

æ­¤è¦ç¯„åœ¨ä¿æŒ Linus é¢¨æ ¼å„ªå…ˆçš„å‰æä¸‹ï¼Œç‚ºæ ¸å¿ƒç®—æ³•å±¤æä¾›äº†æ•¸å­¸åš´è¬¹æ€§å’Œæ–‡å­¸åŒ–ç·¨ç¨‹çš„å¥½è™•ã€‚é—œéµæ˜¯ï¼š

1. **ç¯„åœé™åˆ¶** - åªåœ¨è¤‡é›œç®—æ³•ä¸­ä½¿ç”¨
2. **Linus å„ªå…ˆ** - æ‰€æœ‰å¯¦ç¾å¿…é ˆå…ˆé€šé Linus æª¢æŸ¥
3. **ç°¡æ½”æ–‡æª”** - é¿å…éåº¦æ–‡æª”åŒ–
4. **æ•ˆèƒ½ä¿è­‰** - ä¸å½±éŸ¿ç³»çµ±æ•´é«”æ•ˆèƒ½

è¨˜ä½ï¼š**ã€Œåœ¨æ­£ç¢ºçš„åœ°æ–¹è¿½æ±‚å®Œç¾ï¼Œåœ¨å…¶ä»–åœ°æ–¹ä¿æŒç°¡æ½”ã€**